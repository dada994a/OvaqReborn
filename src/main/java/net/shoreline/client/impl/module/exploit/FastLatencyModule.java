package net.shoreline.client.impl.module.exploit;

import net.minecraft.network.packet.Packet;
import net.minecraft.network.packet.c2s.common.CommonPongC2SPacket;
import net.minecraft.network.packet.c2s.common.KeepAliveC2SPacket;
import net.minecraft.network.packet.c2s.common.ResourcePackStatusC2SPacket;
import net.shoreline.client.api.config.Config;
import net.shoreline.client.api.config.setting.BooleanConfig;
import net.shoreline.client.api.config.setting.NumberConfig;
import net.shoreline.client.api.event.listener.EventListener;
import net.shoreline.client.api.module.ModuleCategory;
import net.shoreline.client.api.module.ToggleModule;
import net.shoreline.client.impl.event.RunTickEvent;
import net.shoreline.client.impl.event.network.PacketEvent;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class FastLatencyModule extends ToggleModule {

    private final Config<Float> minLatencyConfig = new NumberConfig<>("MinLatency", "Minimum delay in ms", 1.0f, 1.0f, 1.0f);
    private final Config<Float> maxLatencyConfig = new NumberConfig<>("MaxLatency", "Maximum delay in ms", 250.0f, 100.0f, 250.0f);
    private final Config<Boolean> autoAdjustPing = new BooleanConfig("AutoAdjust", "Automatic Ping adjustment", true);
    private final ConcurrentMap<Packet<?>, Long> cachedPackets = new ConcurrentHashMap<>();
    private long lastPingCheckTime = System.currentTimeMillis();
    private int currentPing; // Pingの最新値を保持

    public FastLatencyModule() {
        super("FastLatency", "Automatically adjusts the delay to simulate lower latency", ModuleCategory.EXPLOIT);
    }

    @Override
    public String getModuleData() {
        return currentPing + " ms"; // Display current ping
    }

    @Override
    public void onDisable() {
        if (mc.player == null) {
            return;
        }
        if (!cachedPackets.isEmpty()) {
            cachedPackets.forEach((packet, time) -> mc.player.networkHandler.sendPacket(packet));
            cachedPackets.clear();
        }
    }

    @EventListener
    public void onPacketOutbound(PacketEvent.Outbound event) {
        if (mc.player == null || mc.isInSingleplayer()) {
            return;
        }

        if (event.getPacket() instanceof KeepAliveC2SPacket ||
                (event.getPacket() instanceof ResourcePackStatusC2SPacket || event.getPacket() instanceof CommonPongC2SPacket) && autoAdjustPing.getValue()) {

            if (cachedPackets.containsKey(event.getPacket())) {
                cachedPackets.remove(event.getPacket());
                return;
            }
            cachedPackets.put(event.getPacket(), System.currentTimeMillis());
            event.cancel();
        }
    }

    @EventListener
    public void onTick(RunTickEvent event) {
        long currentTime = System.currentTimeMillis();
        if (currentTime - lastPingCheckTime >= 1000) {
            if (mc.player != null && mc.player.networkHandler != null) {
                // プレイヤーリストエントリを取得
                var playerListEntry = mc.player.networkHandler.getPlayerListEntry(mc.player.getUuid());

                if (playerListEntry != null) {
                    // Pingの最新値を取得
                    currentPing = playerListEntry.getLatency();
                }
            }
            lastPingCheckTime = currentTime;
        }

        float targetLatency = calculateLatencyBasedOnPing(currentPing);

        cachedPackets.forEach((packet, time) -> {
            long elapsed = currentTime - time;
            if (elapsed > targetLatency) {
                mc.player.networkHandler.sendPacket(packet);
                cachedPackets.remove(packet);
            }
        });
    }

    private float calculateLatencyBasedOnPing(long ping) {
        float minLatency = minLatencyConfig.getValue();
        float maxLatency = maxLatencyConfig.getValue();

        if (ping > 250) {
            return minLatency;
        }

        return minLatency + ((ping - 1) / 50.0f) * (maxLatency - minLatency);
    }
}
