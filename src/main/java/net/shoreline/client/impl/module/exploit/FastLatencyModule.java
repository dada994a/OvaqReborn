package net.shoreline.client.impl.module.exploit;

import net.minecraft.network.packet.Packet;
import net.minecraft.network.packet.c2s.common.CommonPongC2SPacket;
import net.minecraft.network.packet.c2s.common.KeepAliveC2SPacket;
import net.minecraft.network.packet.c2s.common.ResourcePackStatusC2SPacket;
import net.shoreline.client.api.config.Config;
import net.shoreline.client.api.config.setting.BooleanConfig;
import net.shoreline.client.api.config.setting.NumberConfig;
import net.shoreline.client.api.event.listener.EventListener;
import net.shoreline.client.api.module.ModuleCategory;
import net.shoreline.client.api.module.ToggleModule;
import net.shoreline.client.impl.event.RunTickEvent;
import net.shoreline.client.impl.event.network.PacketEvent;

import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

public class FastLatencyModule extends ToggleModule {

    // 設定項目
    Config<Float> minLatencyConfig = new NumberConfig<>("MinLatency", "Minimum delay in ms", 1.0f, 1.0f, 1.0f);
    Config<Float> maxLatencyConfig = new NumberConfig<>("MaxLatency", "Maximum delay in ms", 250.0f, 100.0f, 250.0f);
    Config<Boolean> autoAdjustPing = new BooleanConfig("AutoAdjust", "Automatic Ping adjustment", true);
    Config<Integer> pingUpdateIntervalConfig = new NumberConfig<>("PingUpdateInterval", "Ping update interval in seconds", 1, 1, 5); // 更新間隔を設定で調整可能に

    // キャッシュされたパケット
    private final ConcurrentMap<Packet<?>, Long> cachedPackets = new ConcurrentHashMap<>();
    private long lastPingCheckTime = System.currentTimeMillis();
    private int currentPing = 0;

    public FastLatencyModule() {
        super("FastLatency", "Automatically adjusts the delay to simulate lower latency", ModuleCategory.EXPLOITS);
    }

    @Override
    public String getModuleData() {
        return currentPing + " ms";
    }

    @Override
    public void onDisable() {
        if (mc.player == null) {
            return;
        }
        if (!cachedPackets.isEmpty()) {
            cachedPackets.forEach((packet, time) -> mc.player.networkHandler.sendPacket(packet));
            cachedPackets.clear();
        }
    }

    // パケット送信時の処理
    @EventListener
    public void onPacketOutbound(PacketEvent.Outbound event) {
        if (mc.player == null || mc.isInSingleplayer()) {
            return;
        }

        Packet<?> packet = event.getPacket();
        if (packet instanceof KeepAliveC2SPacket ||
                (packet instanceof ResourcePackStatusC2SPacket || packet instanceof CommonPongC2SPacket) && autoAdjustPing.getValue()) {

            if (cachedPackets.containsKey(packet)) {
                cachedPackets.remove(packet);
                return;
            }

            cachedPackets.put(packet, System.currentTimeMillis());
            event.cancel();
        }
    }

    @EventListener
    public void onTick(RunTickEvent event) {
        long currentTime = System.currentTimeMillis();
        int pingUpdateInterval = pingUpdateIntervalConfig.getValue() * 1000;

        if (currentTime - lastPingCheckTime >= pingUpdateInterval) {
            updatePing();
            lastPingCheckTime = currentTime;
        }

        float targetLatency = calculateTargetLatency(currentPing);

        cachedPackets.forEach((packet, time) -> {
            long elapsed = currentTime - time;
            if (elapsed > targetLatency) {
                mc.player.networkHandler.sendPacket(packet);
                cachedPackets.remove(packet);
            }
        });
    }

    private void updatePing() {
        if (mc.player != null && mc.player.networkHandler != null) {
            currentPing = mc.player.networkHandler.getPlayerListEntry(mc.player.getUuid()).getLatency();
        }
    }

    private float calculateTargetLatency(long ping) {
        float minLatency = minLatencyConfig.getValue();
        float maxLatency = maxLatencyConfig.getValue();

        return ping < 1 ? minLatency : Math.min(maxLatency, minLatency + (ping - 1) / 150.0f * (maxLatency - minLatency));
    }
}
